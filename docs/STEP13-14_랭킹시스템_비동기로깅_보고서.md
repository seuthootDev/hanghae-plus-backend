### 🎯 랭킹 시스템

#### 1. 선착순 쿠폰 랭킹
- **Redis Sorted Set** 기반 선착순 처리
- **타임스탬프 기반 순위 결정**: `ZADD coupon:queue:${couponType} ${timestamp} ${userId}`
- **재고 관리**: Redis `DECR` 명령어로 원자적 재고 차감
- **중복 발급 방지**: `ZSCORE`로 이미 발급받은 사용자 확인

#### 2. 인기상품 랭킹
- **슬라이딩 윈도우 집계**: 3일간 판매량 기반 랭킹
- **일일 데이터 구조**: `product:ranking:YYYY-MM-DD`
- **전체 랭킹 키**: `product:ranking:3d`
- **자동 정리**: 매일 자정에 3일 전 데이터 삭제 후 재계산

### 🔧 핵심 구현

```typescript
// 선착순 쿠폰 랭킹
private async recordUserRank(userId: number, couponType: string): Promise<number> {
  const key = `coupon:queue:${couponType}`;
  const timestamp = Date.now();
  await this.redisService.zadd(key, timestamp, userId.toString());
  return await this.redisService.zrank(key, userId.toString());
}

// 인기상품 랭킹 업데이트
private async updateProductRanking(orderItems: OrderItem[]): Promise<void> {
  const today = new Date().toISOString().split('T')[0];
  const dailyRankingKey = `product:ranking:${today}`;
  
  for (const item of orderItems) {
    const currentScore = await this.redisService.zscore(dailyRankingKey, item.productId.toString());
    const newScore = (currentScore || 0) + item.quantity;
    await this.redisService.zadd(dailyRankingKey, newScore, item.productId.toString());
  }
}
```

---

### 🎯 비동기 로깅 시스템

#### 1. 설계 목적
- **장애 대응**: 쿠폰 발급과 로그 저장 분리
- **사용자 경험**: 로그 저장 실패해도 쿠폰 발급 완료
- **복구 가능성**: 로그 데이터로 문제 상황 추적

#### 2. 구현 방식
- **setImmediate()**: Node.js 내장 비동기 처리
- **Fire-and-Forget**: 로그 저장 결과를 기다리지 않음
- **장애 격리**: 로그 저장 실패 ≠ 쿠폰 발급 실패

### 🔧 핵심 구현

```typescript
// 쿠폰 발급 시 비동기 로깅
async issueCoupon(issueCouponDto: IssueCouponDto): Promise<Coupon> {
  // 1. 쿠폰 발급 (성공)
  const coupon = await this.createAndSaveCoupon(issueCouponDto);
  
  // 2. 랭킹 업데이트 (성공)
  await this.updateRanking(userId, couponType);
  
  // 3. 로그를 비동기로 저장 (사용자 응답과 별개)
  this.saveRankingLogAsync(userId, couponType, rank);
  
  return coupon; // 사용자는 즉시 응답 받음
}

// 비동기 로그 저장
private saveRankingLogAsync(userId: number, couponType: string, rank: number): void {
  setImmediate(async () => {
    try {
      const rankingLog = RankingLog.create(userId, couponType, rank);
      await this.rankingLogRepository.save(rankingLog);
    } catch (error) {
      console.error('❌ 랭킹 로그 저장 실패:', error.message);
      // 실패해도 메인 기능에 영향 없음
    }
  });
}
```

### 📊 로그 데이터 구조

```sql
CREATE TABLE ranking_logs (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL,
  coupon_type VARCHAR(50) NOT NULL,
  rank INT NOT NULL,
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  status ENUM('ISSUED', 'FAILED') DEFAULT 'ISSUED',
  retry_count INT DEFAULT 0
);
```

---

## 🏁 결론

**선착순 쿠폰 랭킹**, **인기상품 랭킹**, **비동기 로깅** 시스템을 성공적으로 구현했습니다.

### 🎯 구현 완료 내용

**선착순 쿠폰 랭킹**: Redis Sorted Set을 활용하여 타임스탬프 기반의 정확한 순위 결정과 원자적 재고 관리를 구현했습니다. `ZADD`, `ZRANK`, `DECR` 등의 Redis 명령어로 고성능 선착순 처리가 가능합니다.

**인기상품 랭킹**: 기존 집계 테이블을 제거하고 Redis Sorted Set 기반의 슬라이딩 윈도우 집계로 전환했습니다. 일일 데이터를 `product:ranking:YYYY-MM-DD` 형태로 저장하고, 매일 자정에 3일 전 데이터를 정리하며 전체 랭킹을 재계산하는 방식입니다.

**비동기 로깅**: 쿠폰 발급과 랭킹 업데이트가 완료된 후, 사용자 응답과 별개로 `setImmediate()`를 사용하여 랭킹 로그를 비동기적으로 저장합니다. 이는 장애 발생 시에도 복구 가능한 안전한 시스템을 구축하기 위함입니다.

### 💪 기술적 성과

- **성능 향상**: Redis Sorted Set의 O(log N) 복잡도로 랭킹 조회/업데이트 성능 개선
- **메모리 효율성**: TTL 기반 자동 정리와 슬라이딩 윈도우로 메모리 사용량 최적화
- **시스템 안정성**: 비동기 로깅으로 핵심 기능과 로그 저장을 분리하여 장애 격리
- **확장성**: 수백만 상품/쿠폰 랭킹 처리 가능한 구조